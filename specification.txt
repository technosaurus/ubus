UBUS SPECIFICATION DRAFT

   The Unix Stream Bus

1. Motivation

   System V IPC mechanisms offer no utils for situations
   where multiple processes shall be connected.
   Typical applications are system/session daemons which 
   can be accessed by multiple other processes.
   Those applications either have to provide their own
   mechanism, or use dbus.
   Ubus provides such functionality without the need for 
   a system daemon. Its implementation is meant to be simple.
   A ubus implementation can easily be written in pure shell
   (if the shell supports sockets). 
   Ubus establishes bidirectional multicast pipes. While 
   they can be used for any purpose, this specification
   also provides a standard protocol for RMI.

2. Bus

   A bus is a unix domain socket (AF_UNIX and SOCK_STREAM)
   located in:
          /var/ipc/application_name/
   or
          ~/.ipc/application_name/

   depending on, if the owner is a system or session service.

3. Services

   Services are applications providing one or multiple buses.
   They create the socket in the appropriate directory, listen
   for incoming requests, and destroy the bus when they see fit.
   Applications MUST delete the bus on exit, even when exiting
   due to a signal.
   The on disk layout of buses SHOULD reflect the logical object
   layout of the application. The applications ipc directory
   may contain sub-directories.

4. Connections

   A connection is a bidirectional pipe established with a bus.
   An application may establish a connection with a bus, by 
   simply connecting to the file via connect (3).

5. Communication types

   5.1  Signals

      A signal is a bus, where each connection receives 
      a call when a specific event in the service happened.
      Calls sent towards the service are either ignored,
      or not synchronized.

      Signals carry the file ending ".signal".

   5.2  Methods

      On a method connection, a call is sent to the
      service, then the service responds with the 
      return value. Each request MUST be followed by a 
      response, in the same order they were sent.

      Methods carry the file ending ".method".

   5.3  Properties

      Upon connection, the service immediately sends the 
      current value to the client. A client may then send 
      a new value. If the new value is accepted, it is 
      again written to all connections. If it is rejected
      an error (bell) COULD BE sent and the connection is 
      terminated.

      Properties carry the file ending ".property". 


    5.4  Restful bus
        
      A client first sends a request,  then closes the write 
      channel. The service sends a response, and closes the
      read channel. Both request and response may be empty.
      Error handling must be implemented at application
      level.

      Rest buses carry the file ending ".rest". 


6 RMI Format

   6.1 Call

      A call consists of multiple arguments separated 
      by tab (ascii 9) and terminated by newline (ascii 10).

      A call contains zero or more arguments.
      Implementations MUST at least support a call size
      (until \n) of 1024Bytes. They SHOULD support
      unlimited size. Exceeding the implementation
      limit SHOULD result in an immediate disconnect.

   6.2 Argument

      An argument is a utf8 string.
      Numbers are printed and parsed as they would in
      printf (3).

      Control characters in arguments are encoded.
      0 (null) -->   \e0  ( 96 followed by 8 )
      7 (bell) -->  \ea  (  97  followed by 8 )
      8 (backspace) --> \eb
      9 (tab) --> \et
      10 (newline) --> \en
      11 (vtab)    --> \ev
      12 (formfeed) --> \ef
      13 (return)  --> \er
      27 (escape)  --> \ee
      
      Complex types are formed with \e{ \e} \e[ \e] \v and can 
      be  nested infinitely deep. All elements MUST end in \v, 
      including {} [].  \v and \e here are literal ascii 12 
      and 27. Implementations should simply split by \v and 
      use { } [] as indication for nesting.

      Associative Array:  
          Elements MUST be formed of key\vvalue\v, 
          where key MUST NOT be empty.
          \e{\va\vfoo\vb\vbar\vs\vbaz\vg\v\e{\va\v1\vc\vbla\v\e}\v\e}\v

          for readability, \v is shown as space here:
          \e{ a  foo  b  bar  s  baz  g  \e{ a  1 c  bla \e} \e}

          for clarity, here the same thing in json notation:
          { a:foo, b:bar, s:baz,  g : { a:1 , c:bla } }

      Indexed Array:  
          \e[\vb\v\e[\vfoo\vbar\v\e]\vbla\vbaz\v\e]\v

          readable:
          \e[ b \e[ foo bar \e]  bla baz \e]

          same array in json:
          [ b, [ foo bar ] , bla, baz]

      Binary data SHOULD be sent the same way as strings.

   6.3 Error handling

      Errors can be indicated by sending a bell (ascii 7)
      then an error number, then optionally tab followed by
      a message, then newline.
      The error number SHOULD be a posix errno. If it is not,
      it MUST NOT clash with a posix errno.

      Other control characters are reserved for future use.
      Lines beginning with such a character, MUST be ignored.



7. Bus discovery and recovery

   Applications may establish connections to services that 
   are not started yet. Implementations SHOULD use inotify
   or other available utils to monitor the path for creation
   of the file.
   If a socket is a zombie, implementations SHOULD attemp to
   reconnect when the file is recreated. Implementations 
   MUST handle unexpected disconnect gracefully. They SHOULD
   provide an option for automatic reconnection.

8. Security

   Standard unix file permissions are used to prevent access 
   from unauthorized users. Access rights SHOULD NOT change. 
   Implementations MUST fail immediately to connect to a socket 
   without required permissions ( as opposed to trying until 
   success )

9. Buses on remote hosts

   Implementations SHOULD provide a way to connect to a bus 
   on a remote machine, via ssh. 
   The url format for remote buses is:
      user:password@host:/path/to/bus
   user and password are optional. if the path does not begin 
   with a /, it is relative to the remote home directory.
   Implementations may assume the "ubus" binary to be available
   on the remote host, so they may simple popen (3):
      "ssh host ubus connect /path/to/bus"

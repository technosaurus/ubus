UBUS SPECIFICATION DRAFT

   The Unix Stream Bus

1. Motivation

   System V IPC mechanisms offer no utils for situations
   where multiple processes shall be connected.
   Typical applications are system/session daemons which 
   can be accessed by multiple other processes.
   Those applications either have to provide their own
   mechanism, or use dbus.
   Ubus provides such functionality without the need for 
   a system daemon. Its implementation is meant to be simple.
   A ubus implementation can easily be written in pure shell
   (if the shell supports sockets). 
   Ubus establishes bidirectional multicast pipes. While 
   they can be used for any purpose, this specification
   also provides a standard protocol for RMI.

2. Bus

   A bus is a unix domain socket (AF_UNIX and SOCK_STREAM)
   located in:
          /var/ipc/application_name/
   or
          ~/.ipc/application_name/

   depending on, if the owner is a system or session service.

3. Services

   Services are applications providing one or multiple buses.
   They create the socket in the appropriate directory, listen
   for incoming requests, and destroy the bus when they see fit.
   Applications MUST delete the bus on exit, even when exiting
   due to a signal.
   The on disk layout of buses SHOULD reflect the logical object
   layout of the application. The applications ipc directory
   may contain sub-directories.

4. Connections

   A connection is a bidirectional pipe established with a bus.
   An application may establish a connection with a bus, by 
   simply connecting to the file via connect (3).

5. Communication types

   5.1  Signals

      A signal is a bus, where each connection receives 
      a call when a specific event in the service happened.
      Calls sent towards the service are either ignored,
      or not synchronized.

      Signals carry the file ending ".signal".

   5.2  Methods

      On a method connection, a call is sent to the
      service, then the service responds with the 
      return value. Each request MUST be followed by a 
      response, in the same order they were sent.

      Methods carry the file ending ".method".

   5.3  Properties

      Upon connection, the service immediately sends the 
      current value to the client. A client may then send 
      a new value. If the new value is accepted, it is 
      again written to all connections. If it is rejected
      an error (bell) COULD BE sent and the connection is 
      terminated.

      Properties carry the file ending ".property". 


    5.4  Restful bus
        
      A client first sends a request,  then closes the write 
      channel. The service sends a response, and closes the
      read channel. Both request and response may be empty.
      Error handling must be implemented at application
      level.

      Rest buses carry the file ending ".rest". 


6 RMI Format

   6.1 Call

      A call consists of multiple arguments separated 
      by tab (ascii 9) and terminated by newline (ascii 10).

      A call contains zero or more arguments.
      Implementations MUST at least support a call size
      (line including \n) of 256000 Bytes. (250Kb).
      They SHOULD support unlimited size. Exceeding the 
      implementation limit SHOULD result in an immediate 
      disconnect, but at least MUST be responded with 
      an error 75 ( EOVERFLOW )

   6.2 Argument

      An argument is a utf8 string.
      Numbers are printed and parsed as they would in
      printf (3).

      Control characters in arguments are encoded.
      0 (null) -->   \e0  ( 27 followed by 48 )
      7 (bell) -->  \ea  (  27  followed by 97 )
      8 (backspace) --> \eb
      9 (tab) --> \et
      10 (newline) --> \en
      11 (vtab)    --> \ev
      12 (formfeed) --> \ef
      13 (return)  --> \er
      27 (escape)  --> \ee
      
      Complex types are formed with \e{ \e} \e[ \e] \v and can 
      be  nested infinitely deep. All elements MUST end in \v, 
      including {} [].  \v and \e here are literal ascii 12 
      and 27. Implementations should simply split by \v and 
      use { } [] as indication for nesting.

      Associative Array:  
          Elements MUST be formed of key\vvalue\v, 
          where key MUST NOT be empty.
          \e{\va\vfoo\vb\vbar\vs\vbaz\vg\v\e{\va\v1\vc\vbla\v\e}\v\e}\v

          for readability, \v is shown as space here:
          \e{ a  foo  b  bar  s  baz  g  \e{ a  1 c  bla \e} \e}

          for clarity, here the same thing in json notation:
          { a:foo, b:bar, s:baz,  g : { a:1 , c:bla } }

      Indexed Array:  
          \e[\vb\v\e[\vfoo\vbar\v\e]\vbla\vbaz\v\e]\v

          readable:
          \e[ b \e[ foo bar \e]  bla baz \e]

          same array in json:
          [ b, [ foo bar ] , bla, baz]

      Binary data SHOULD be sent the same way as strings.

   6.3 Error handling

      Errors can be indicated by sending a bell (ascii 7)
      then an error number, then optionally tab followed by
      a message, then newline.
      The error number SHOULD be a posix errno. If it is not,
      it MUST NOT clash with a posix errno.

      Other control characters are reserved for future use.
      Lines beginning with such a character, MUST be ignored.


7. Bus discovery and recovery

   Applications may establish connections to services that 
   are not started yet. Implementations SHOULD use inotify
   or other available utils to monitor the path for creation
   of the file.
   If a socket is a zombie, implementations SHOULD attemp to
   reconnect when the file is recreated. Implementations 
   MUST handle unexpected disconnect gracefully. They SHOULD
   provide an option for automatic reconnection.

8. Security

   Standard unix file permissions are used to prevent access 
   from unauthorized users. Access rights SHOULD NOT change. 
   Implementations MUST fail immediately to connect to a socket 
   without required permissions ( as opposed to trying until 
   success )

9. Scripting interface

   Binaries are provided that help in scripting and remoting.   

   If a path to a bus does not begin with "/" or "./" , 
   it is relative to ~/.ipc/.

   9.1 "ubus"

      The "ubus" binary allocates channels and maintains 
      connections.
      Messages from connections are written to stdout, 
      prefixed with an identifier for the bus and the client.
      They are rewritten as
        command\tbus\tclient\tactualmessage\n, 
      so that the ids are actually rmi arguments.

      for the sake of readability, all \t are shown here 
      as space again.

      Commands via stdin:

        b 4 app/fish.signal : create a new bus app/fish.signal 
                              and identify it with "4"
        u 4                 : destroy bus 4
        w 4 123 ...         : message client 123 on bus 4
        d 4 123             : disconnect client 123 on bus 4

      On stdout you get:

        b 4 1               : bus 4 created
        b 4 0 123 dummy     : bus 4 not created because of
                              error 123 "dummy"
        c 4 123             : client 123 connected
        r 4 123 ...         : message from client 123
        d 4 123             : client 123 disconnected


      The identifier is arbitrary text, and can be reused for 
      a new client, after an old one disconnected.
      A * can be used as client identifier to mean all 
      connected clients, ie broadcast. A * in the bus identifier
      has no meaning, and is part of the name.

      Lines beginning with an unknown command, MUST be ignored.

      Commandline arguments are interpreted as buses to open.
      Ie, ubus foo/bla bar/baz  will open two channels and give 
      them the idents 1 and 2.

      Client connections to existing buses are also possible:

        k 5 app/fish.signal : connect to bus app/fish.signal
        i 5                 : disconnect 

      On stdout:

        k 5 1               : bus 4 connected
        k 5 0 123 dummy     : bus 4 not connected because of
                              error 123 "dummy"
      
      Read/writes are the same as with buses you created. The
      client identifier must then always be empty.

    9.3 "ubus-signal"
    
      Creates one bus given as command line argument.
      Does not prefix any message. Stdin is broadcasted, 
      Stdout shows all data from all clients, interleaved. 
      Can be used for properties as well.

    9.4 "ubus-connect"

      connects to one bus given as command line argument.
      stdin/stdout are wired to the bus.
    
      Identical to "socat STDIO UNIX-CONNECT:/path/to/bus", except 
      that it is safe to assume its existence.

10. Buses on remote machines

   10.1 ssh

     Applications can create and connect to buses on remote 
     machines, via ssh. For that to work, the remote machine
     must have the scripting interface installed.

     An implementation can just call 
       "ssh host ubus"
   
   10.2 tcp

    TODO: inetd? whats with encryption? do we even care?
